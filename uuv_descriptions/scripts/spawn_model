#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rclpy.qos import QoSProfile

import sys
import os
import time
import warnings
import re

from gazebo_msgs.msg import ModelStates
from gazebo_msgs.srv import SpawnEntity, SpawnEntityRequest
from std_srvs.srv import Empty
from geometry_msgs.msg import Point, Pose, Quaternion
import tf_transformations as tft

try:
    import pymap3d
    use_pymap = True
except Exception as ex:
    print('Package pymap3d is not available, WGS84 coordinates cannot be used\n'
          'Download pymap3d for Python 3.x as\n'
          '>> pip install pymap3d')
    use_pymap = False

model_database_template = """<sdf version="1.4">
  <world name="default">
    <include>
      <uri>model://MODEL_NAME</uri>
    </include>
  </world>
</sdf>"""


def usage():
    """Print usage instructions for this script."""
    print('''Commands:
    -[urdf|sdf|trimesh] - specify incoming xml is urdf, sdf or trimesh
    -[file|param|database] [<file_name>|<param_name>|<model_name>] - source of the model xml or the trimesh file
    -model <model_name> - name of the model to be spawned.
    -reference_frame <entity_name> - optional: name of the model/body where initial pose is defined.
    -robot_namespace <robot ros_namespace> - optional: change ROS namespace of gazebo-plugins.
    -unpause - optional: unpause physics after spawning model
    -wait - optional: wait for model to exist
    -trimesh_mass <mass in kg> - required if -trimesh is used: linear mass
    -x <x in meters> - optional: initial pose, use 0 if left out
    -y <y in meters> - optional: initial pose, use 0 if left out
    -z <z in meters> - optional: initial pose, use 0 if left out
    -R <roll in radians> - optional: initial pose, use 0 if left out
    -P <pitch in radians> - optional: initial pose, use 0 if left out
    -Y <yaw in radians> - optional: initial pose, use 0 if left out
    ''')
    sys.exit(1)

class SpawnModel(Node):

    def __init__(self):
        super().__init__('spawn_model')
        self.initial_xyz = [0,0,0]
        self.initial_rpy = [0,0,0]
        self.initial_geo = [None,None,None]
        self.ref_geo = [None,None,None]
        self.initial_q = [0,0,0,1]
        self.file_name = ""
        self.param_name = ""
        self.database_name = ""
        self.model_name = ""
        self.robot_namespace = self.get_namespace()
        self.unpause_physics = False
        self.wait_for_model = ""
        self.wait_for_model_exists = False
        self.urdf_format = False
        self.sdf_format = False

    def parseUserInputs(self):
        # get goal from commandline
        for i in range(0, len(sys.argv)):
            if sys.argv[i] == '-h' or sys.argv[i] == '--help':
                usage()
                sys.exit(1)
            if sys.argv[i] == '-unpause':
                self.unpause_physics = True
            if sys.argv[i] == '-urdf':
                if self.sdf_format:
                    print("Error: you cannot specify both urdf and sdf format xml, must pick one")
                    sys.exit(0)
                else:
                    self.urdf_format = True
            if sys.argv[i] == '-sdf':
                if self.urdf_format:
                    print("Error: you cannot specify both urdf and sdf format xml, must pick one")
                    sys.exit(0)
                else:
                    self.sdf_format = True
            if sys.argv[i] == '-param':
                if len(sys.argv) > i+1:
                    self.param_name = sys.argv[i+1]
                    self.get_logger().info('Parameter name: %s' % self.param_name)
            if sys.argv[i] == '-file':
                if len(sys.argv) > i+1:
                    self.file_name = sys.argv[i+1]
            if sys.argv[i] == '-database':
                if len(sys.argv) > i+1:
                    self.database_name = sys.argv[i+1]
            if sys.argv[i] == '-model':
                if len(sys.argv) > i+1:
                    self.model_name = sys.argv[i+1]
            if sys.argv[i] == '-wait':
                if len(sys.argv) > i+1:
                    self.wait_for_model = sys.argv[i+1]
            if sys.argv[i] == '-reference_frame':
                if len(sys.argv) > i+1:
                    self.reference_frame = sys.argv[i+1]
            if sys.argv[i] == '-x':
                if len(sys.argv) > i+1:
                    self.initial_xyz[0] = float(sys.argv[i+1])
            if sys.argv[i] == '-y':
                if len(sys.argv) > i+1:
                    self.initial_xyz[1] = float(sys.argv[i+1])
            if sys.argv[i] == '-z':
                if len(sys.argv) > i+1:
                    self.initial_xyz[2] = float(sys.argv[i+1])
            if sys.argv[i] == '-R':
                if len(sys.argv) > i+1:
                    self.initial_rpy[0] = float(sys.argv[i+1])
            if sys.argv[i] == '-P':
                if len(sys.argv) > i+1:
                    self.initial_rpy[1] = float(sys.argv[i+1])
            if sys.argv[i] == '-Y':
                if len(sys.argv) > i+1:
                    self.initial_rpy[2] = float(sys.argv[i+1])
        
        if not self.sdf_format and not self.urdf_format:
            print("Error: you must specify incoming format as either urdf or sdf format xml")
            sys.exit(0)
        if self.model_name == "":
            print("Error: you must specify model name")
            sys.exit(0)

        # Overriding initial pose via ros parameters
        if self.has_parameter('xref'):
            self.initial_xyz[0] = float(self.get_parameter('xref').value)
        if self.has_parameter('yref'):
            self.initial_xyz[1] = float(self.get_parameter('yref').value)
        if self.has_parameter('zref'):
            self.initial_xyz[2] = float(self.get_parameter('zref').value)
        if self.has_parameter('rollref'):
            self.initial_rpy[0] = float(self.get_parameter('rollref').value)
        if self.has_parameter('pitchref'):
            self.initial_rpy[1] = float(self.get_parameter('pitchref').value)
        if self.has_parameter('yawref'):
            self.initial_rpy[2] = float(self.get_parameter('yawref').value)

    def checkForModel(self, msg):
        for n in msg.name:
            if n == self.wait_for_model:
                self.wait_for_model_exists = True

    def createDatabaseCode(self, database_name):
        return model_database_template.replace("MODEL_NAME", database_name)

    def callSpawnService(self):
        qos_profile = QoSProfile(depth=10)
        self.create_subscription(ModelStates, f"{self.robot_namespace}/model_states", self.checkForModel, qos_profile)

        if not self.wait_for_model == "":
            while rclpy.ok() and not self.wait_for_model_exists:
                rclpy.spin_once(self)

        if rclpy.ok() and len(self.file_name) > 0:
            self.get_logger().info("Loading model xml from file")
            if os.path.exists(self.file_name):
                if os.path.isfile(self.file_name):
                    with open(self.file_name, 'r') as f:
                        model_xml = f.read()
                    if model_xml == "":
                        self.get_logger().error("Error: file is empty")
                        sys.exit(0)
                else:
                    self.get_logger().error("Error: file name is an invalid path")
                    sys.exit(0)
            else:
                self.get_logger().error("Error: file does not exist")
                sys.exit(0)
        
        elif len(self.param_name) > 0:
            self.get_logger().info("Loading model xml from ros parameter")
            model_xml = self.get_parameter(self.param_name).value
            if model_xml == "":
                self.get_logger().error("Error: param does not exist or is empty")
                sys.exit(0)

        elif len(self.database_name) > 0:
            self.get_logger().info("Loading model xml from Gazebo Model Database")
            model_xml = self.createDatabaseCode(self.database_name)
            if model_xml == "":
                self.get_logger().error("Error: an error occurred generating the SDF file")
                sys.exit(0)
        else:
            self.get_logger().error("Error: user specified param or filename is an empty string")
            sys.exit(0)

        if self.unpause_physics:
            self.get_logger().info("Waiting for service to unpause physics")
            self.wait_for_service(f"{self.robot_namespace}/unpause_physics")

            unpause_client = self.create_client(Empty, f"{self.robot_namespace}/unpause_physics")
            unpause_request = Empty.Request()
            future = unpause_client.call_async(unpause_request)
            rclpy.spin_until_future_complete(self, future)

        # Setting initial pose
        initial_pose = Pose()
        if None not in self.initial_geo and None not in self.ref_geo and use_pymap:
            self.get_logger().info('Using the geodetic coordinates to spawn the model')
            enu_pos = pymap3d.geodetic2enu(
                self.initial_geo[0], self.initial_geo[1], self.initial_geo[2],
                self.ref_geo[0], self.ref_geo[1], self.ref_geo[2])
            initial_pose.position.x = enu_pos[0]
            initial_pose.position.y = enu_pos[1]
            initial_pose.position.z = enu_pos[2]
        else:
            self.get_logger().info('Using the ENU coordinates to spawn the model')
            initial_pose.position.x = self.initial_xyz[0]
            initial_pose.position.y = self.initial_xyz[1]
            initial_pose.position.z = self.initial_xyz[2]

        self.get_logger().info('Initial position wrt the world frame:'
                      ' (%.2f, %.2f, %.2f)' %
                      (initial_pose.position.x, initial_pose.position.y,
                       initial_pose.position.z))
        # convert rpy to quaternion for Pose message
        tmpq = tft.quaternion_from_euler(
            self.initial_rpy[0], self.initial_rpy[1], self.initial_rpy[2])
        q = Quaternion(x=tmpq[0], y=tmpq[1], z=tmpq[2], w=tmpq[3])
        initial_pose.orientation = q

        spawn_client = self.create_client(SpawnEntity, f"{self.robot_namespace}/spawn_entity")
        spawn_request = SpawnEntity.Request()
        spawn_request.name = self.model_name
        spawn_request.xml = model_xml
        spawn_request.robot_namespace = self.robot_namespace
        spawn_request.pose = initial_pose
        spawn_request.reference_frame = self.reference_frame

        self.get_logger().info("Calling spawn service")
        future = spawn_client.call_async(spawn_request)
        rclpy.spin_until_future_complete(self, future)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(usage())
    else:
        rclpy.init()
        sm = SpawnModel()
        sm.parseUserInputs()
        sm.callSpawnService()
        rclpy.shutdown()